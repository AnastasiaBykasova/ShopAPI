### Суть проекта
- Реализация REST API, который позволит взаимодействовать с базой данных клиентов магазина бытовой техники. Этот API будет:
1. Реализовывать основные CRUD операции (Create, Read, Update, Delete) для сущности "Клиент".
2. Иметь валидацию входящих данных (на этапе создания и обновления клиента).
3. Правильно обрабатывать ошибки (400, 404) и возвращать соответствующие коды и сообщения.
4. Поддерживать пагинацию при получении списка клиентов.
5. Использовать DTO для передачи данных между слоями приложения.
6. Использовать мапперы для преобразования моделей из слоя БД в DTO и обратно.
7. Использовать паттерн Repository для доступа к данным БД.
8. Иметь спецификацию OpenAPI для документации API, доступную через Swagger UI.
9. Иметь RESTful API с корректными методами и путями.

## Этап 1: Настройка окружения и проекта
### Настройка окружения
- Создание проекта (Maven).
- Подключение необходимых зависимостей (PostgreSQL драйвер, JSON библиотека, библиотека для маппинга).

### Настройка Swagger.
- Добавление зависимости
- Для кастомного пути добавляем custom springdoc property в spring-boot configuration file.
- Swagger-спецификация отдается по адресу `http://localhost:8080/swagger/index.html`

### Нормализация БД
1. Проектируем БД
<br><img src="screenshots/db.png" width="700" alt="db">
<br>*Первоначальная БД*
2. Проверяем на соответствие нормальным формам
<br><img src="screenshots/normalization.png" width="700" alt="normalization">
<br>*Соответствие НФ*
3. Реализуем БД в PostgreSQL
<br><img src="screenshots/DBpostgresql.png" width="700" alt="DBpostgresql">
<br>*Схема базы данных*

## Этап 2: Определение моделей данных
### Реализация моделей
- Создание классов для сущностей (Entity).
- Сущности — это фундамент приложения, так как они представляют данные, которые будут храниться в базе данных.
- Определяем структуру таблиц в базе данных в виде классов Java, используя аннотации JPA (`@Entity`, `@Table`, `@Id`, `@Column`). Определяем поля, типы данных, ограничения.
- Получаем классы, которые Hibernate сможет использовать для взаимодействия с базой данных.

## Этап 3: Реализация доступа к данным
### Реализация репозиториев (DAL)
- Репозитории обеспечивают доступ к данным, представленным в виде сущностей.
- Создаем интерфейсы, которые расширяют JpaRepository (или другие репозитории Spring Data). Это даёт готовые методы для CRUD-операций.
- Получаем интерфейсы, которые позволяют извлекать, сохранять, обновлять и удалять данные из базы данных без написания SQL-запросов.

### Реализация DTO
- DTO нужны для представления данных, которые будут передаваться между слоями приложения (например, из сервиса в контроллер) или отправляться клиенту.
- Определяем классы, которые будут использоваться для передачи данных. DTO содержат только необходимые поля, в отличие от сущностей, которые могут содержать все поля таблицы.
- Получаем классы, которые позволяют передавать данные между слоями, скрывая внутреннюю структуру сущностей.

## Этап 4: Реализация маппинга
### Реализация маппинга
- Мапперы необходимы для преобразования данных между Entities и DTO.
- Создаем интерфейсы, которые содержат методы для преобразования данных из одного объекта в другой. Используем библиотеки типа MapStruct для автоматизации маппинга.
- Получаем компоненты, которые позволяют легко преобразовывать данные между разными представлениями (сущности и DTO).

## Этап 5: Реализация бизнес-логики
### Реализация Service Layer
- Сервисы содержат бизнес-логику приложения.
- Создаем классы, которые реализуют бизнес-логику. Используем репозитории для доступа к данным, мапперы для преобразования между сущностями и DTO.
- Получаем компоненты, которые инкапсулируют логику приложения, координируют доступ к данным и их обработку.

## Этап 6: Реализация REST API
### Создание контроллеров
- Контроллеры — это входные точки приложения, обрабатывающие HTTP-запросы.
- Создаем контроллеры, которые принимают HTTP-запросы, вызывают методы сервисов для обработки запросов, преобразовывают результаты в HTTP-ответы.
- Реализация валидации данных. 
- Получаем компоненты, которые позволяют взаимодействовать с вашим приложением через HTTP.
- Реализовываем методы для обработки запросов:
  - `POST /`: для создания клиента (`@RequestBody`,  `@Valid`).
  - `GET /{id}`: для получения клиента по ID (`@PathVariable`).
  - `GET /`: для получения всех клиентов с пагинацией (`@RequestParam` для limit и offset).
    - page: Номер страницы, начиная с 0. Первая страница — 0, вторая — 1, и т. д.
    - limit: Количество элементов на странице.
  - `GET /search`: для получения клиентов по имени и фамилии (`@RequestParam` firstName и lastName).
  - `PUT /{id}`: для обновления клиента (`@PathVariable`, `@RequestBody`, `@Valid`).
  - `PATCH /{id}`: для частичного обновления (`@PathVariable`, `@RequestBody`, `@Valid`).
  - `DELETE /{id}`: для удаления клиента (`@PathVariable`).
- Используем DTO для передачи данных.
- Обрабатываем исключения, используя `@ExceptionHandler` для возврата корректных HTTP кодов ошибок.

### Документация
- Генерация Swagger документации.

### Обработка ошибок
- Реализация обработки исключений.

## Этап 7: Настройка и тестирование
### Запуск
- Настройка сервера (например, Tomcat)

### Настройка Swagger
- Настройка springdoc в application.properties или application.yml (путь к Swagger UI).
- Добавление аннотаций Swagger к контроллерам для описания API.

### Тестирование
- Запуск приложения.
- Swagger UI в браузере (http://localhost:{YourPort}/swagger/index.html).
- Использование Swagger UI для проверки работы всех API.
- Использование Postman или Curl для более детального тестирования.
- Написание Unit-тестов для тестирования Service-слоя.

### Связи между компонентами:
- Сущность и Репозиторий: репозиторий использует сущность для выполнения операций с базой данных. Репозиторий получает данные из базы в виде сущностей, сохраняет сущности в базе и т.д.
- Сущность и Маппер: маппер преобразовывает сущность в DTO (и наоборот).
- DTO и Маппер: маппер использует DTO для преобразования данных.
- Сервис и Репозиторий: сервис использует репозиторий для доступа к данным в базе данных.
- Сервис и Маппер: сервис использует маппер для преобразования сущностей в DTO и обратно.
- Контроллер и Сервис: контроллер вызывает методы сервиса для обработки запросов.
- Контроллер и DTO: контроллер работает с DTO, принимая и отправляя их как данные в HTTP-запросах и ответах.

### Дополнительные улучшения
- Убедиться, что API соответствует RESTful принципам. 
- Обработать все возможные ошибки корректно (400, 404 и т.д.). 
- Рефакторинг кода.

## Результат
- Swagger
<br><img src="screenshots/swagger.png" width="700" alt="swagger">
<br>*Спроектированные API*